---
title: Python进阶知识
description: Python高级特性与Pythonic技巧 - 生成器、装饰器、上下文管理器、性能优化
date: 2026-02-10
tags:
  - python
  - advanced
  - pythonic
  - best-practices
  - performance
category: 速查与资源
status: active
aliases:
  - 进阶知识
  - 高级特性
  - Pythonic
parent: "[[00-导航-Python编程导航]]"
up: "[[00-MOC-知识地图]]"
---

# Python 进阶知识

> Python高级特性和编程技巧，帮助你写出更Pythonic的代码

---

## 1. 面向对象编程（OOP）

### 1.1 类和对象基础
```python
class Person:
    # 类属性
    species = "人类"
    
    # 构造方法
    def __init__(self, name, age):
        self.name = name      # 实例属性
        self._age = age       # 约定：受保护属性
        self.__id = "secret"  # 名称修饰：私有属性
    
    # 实例方法
    def introduce(self):
        return f"我是{self.name}，{self._age}岁"
    
    # 类方法
    @classmethod
    def create_anonymous(cls):
        return cls("匿名", 0)
    
    # 静态方法
    @staticmethod
    def is_adult(age):
        return age >= 18

# 创建对象
person = Person("张三", 25)
print(person.introduce())
```

### 1.2 继承
```python
class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)  # 调用父类构造
        self.student_id = student_id
    
    # 方法重写
    def introduce(self):
        base = super().introduce()
        return f"{base}，学号：{self.student_id}"
    
    # 新方法
    def study(self, subject):
        return f"{self.name}正在学习{subject}"

# 多继承
class TeachingAssistant(Student, Person):
    pass

# 查看继承链
print(TeachingAssistant.__mro__)
```

### 1.3 魔术方法（特殊方法）
```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # 字符串表示
    def __str__(self):      # 面向用户
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):     # 面向开发者
        return f"Vector({self.x!r}, {self.y!r})"
    
    # 算术运算
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
    
    # 比较
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    
    # 长度
    def __len__(self):
        return 2
    
    # 可调用
    def __call__(self):
        return self.x + self.y
    
    # 索引访问
    def __getitem__(self, index):
        return [self.x, self.y][index]

v1 = Vector(1, 2)
v2 = Vector(3, 4)
v3 = v1 + v2  # Vector(4, 6)
```

### 1.4 属性装饰器
```python
class Temperature:
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        """获取摄氏度"""
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        """设置摄氏度"""
        if value < -273.15:
            raise ValueError("温度不能低于绝对零度")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """获取华氏度"""
        return self._celsius * 9/5 + 32

# 使用
temp = Temperature(25)
print(temp.celsius)      # 25（像属性一样访问）
temp.celsius = 30        # 像属性一样设置
print(temp.fahrenheit)   # 86.0
```

---

## 2. 装饰器

### 2.1 函数装饰器
```python
import functools
import time

# 基础装饰器
def my_decorator(func):
    @functools.wraps(func)  # 保留原函数元数据
    def wrapper(*args, **kwargs):
        print("函数执行前")
        result = func(*args, **kwargs)
        print("函数执行后")
        return result
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

# 带参数的装饰器
def repeat(num):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(num):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello {name}")

# 实用装饰器：计时
def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"{func.__name__} 耗时: {elapsed:.4f}秒")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
```

### 2.2 类装饰器
```python
def singleton(cls):
    """单例模式装饰器"""
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class Database:
    def __init__(self):
        self.connection = "已连接"
```

---

## 3. 生成器和迭代器

### 3.1 生成器函数
```python
# 使用yield创建生成器
def fibonacci(n):
    """生成前n个斐波那契数"""
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# 使用
for num in fibonacci(10):
    print(num)

# 生成器表达式
gen = (x**2 for x in range(1000000))  # 惰性求值，节省内存
```

### 3.2 自定义迭代器
```python
class Countdown:
    def __init__(self, start):
        self.start = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 1
        return self.start + 1

# 使用
count = Countdown(5)
for num in count:
    print(num)  # 5, 4, 3, 2, 1
```

### 3.3 itertools模块
```python
import itertools

# 无限迭代器
counter = itertools.count(start=10, step=2)  # 10, 12, 14, ...
cycle = itertools.cycle(["A", "B", "C"])      # A, B, C, A, B, C...

# 组合
list(itertools.combinations([1, 2, 3], 2))     # [(1,2), (1,3), (2,3)]
list(itertools.permutations([1, 2, 3], 2))     # [(1,2), (1,3), (2,1), ...]
list(itertools.product([1, 2], ["a", "b"]))    # [(1,a), (1,b), (2,a), (2,b)]

# 分组
data = [("A", 1), ("A", 2), ("B", 3)]
for key, group in itertools.groupby(data, key=lambda x: x[0]):
    print(key, list(group))
```

---

## 4. 上下文管理器

### 4.1 with语句
```python
# 文件操作（自动关闭）
with open('file.txt', 'r') as f:
    content = f.read()

# 线程锁
import threading
lock = threading.Lock()
with lock:
    # 临界区代码
    pass
```

### 4.2 自定义上下文管理器
```python
from contextlib import contextmanager

# 类方式
class Timer:
    def __enter__(self):
        self.start = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.elapsed = time.time() - self.start
        print(f"耗时: {self.elapsed:.4f}秒")
        return False  # 不处理异常

# 使用
with Timer() as t:
    time.sleep(1)

# 装饰器方式
@contextmanager
def managed_resource(name):
    print(f"获取资源: {name}")
    yield name
    print(f"释放资源: {name}")

with managed_resource("数据库连接") as resource:
    print(f"使用资源: {resource}")
```

---

## 5. 函数式编程

### 5.1 高阶函数
```python
# map: 映射
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))

# filter: 过滤
evens = list(filter(lambda x: x % 2 == 0, numbers))

# reduce: 归约
from functools import reduce
product = reduce(lambda x, y: x * y, numbers)  # 120

# sorted: 排序
words = ["banana", "pie", "Washington"]
sorted(words, key=len)  # 按长度排序
```

### 5.2 偏函数
```python
from functools import partial

# 固定部分参数
base_two = partial(int, base=2)
base_two("1010")  # 10

# 实用场景
print_with_semicolon = partial(print, sep="; ")
print_with_semicolon(1, 2, 3)  # 1; 2; 3
```

### 5.3 闭包
```python
def make_multiplier(n):
    """创建乘法器函数"""
    def multiplier(x):
        return x * n
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))   # 10
print(triple(5))   # 15
```

---

## 6. 模块和包管理

### 6.1 模块组织
```
myproject/
├── main.py
├── config.py
├── utils/
│   ├── __init__.py
│   ├── helpers.py
│   └── validators.py
└── models/
    ├── __init__.py
    └── user.py
```

### 6.2 导入技巧
```python
# 绝对导入
from utils.helpers import format_date

# 相对导入（包内）
from . import helpers
from ..config import settings

# 动态导入
module_name = "math"
math = __import__(module_name)

# 更推荐的方式
import importlib
math = importlib.import_module("math")
```

### 6.3 包配置
```python
# __init__.py
"""工具包"""
__version__ = "1.0.0"

from .helpers import format_date
from .validators import is_email

__all__ = ['format_date', 'is_email']
```

---

## 7. 并发编程

### 7.1 多线程
```python
import threading
import time

def worker(num):
    print(f"线程 {num} 开始")
    time.sleep(1)
    print(f"线程 {num} 结束")

# 创建线程
threads = []
for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

# 等待完成
for t in threads:
    t.join()

# 线程池
from concurrent.futures import ThreadPoolExecutor

with ThreadPoolExecutor(max_workers=5) as executor:
    results = executor.map(worker, range(5))
```

### 7.2 多进程
```python
from multiprocessing import Process, Pool
import os

def worker(num):
    print(f"进程 {num}, PID: {os.getpid()}")

# 创建进程
processes = []
for i in range(5):
    p = Process(target=worker, args=(i,))
    processes.append(p)
    p.start()

# 进程池
with Pool(processes=4) as pool:
    results = pool.map(worker, range(10))
```

### 7.3 异步编程
```python
import asyncio

async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    # 顺序执行
    await say_after(1, "hello")
    await say_after(2, "world")
    
    # 并发执行
    await asyncio.gather(
        say_after(1, "hello"),
        say_after(2, "world")
    )

# 运行
asyncio.run(main())
```

---

## 8. 错误处理和日志

### 8.1 高级异常处理
```python
# 多个异常
try:
    risky_operation()
except (ValueError, TypeError) as e:
    print(f"值错误: {e}")
except Exception as e:
    print(f"其他错误: {e}")
else:
    print("成功执行")
finally:
    print("清理资源")

# 异常链
try:
    something()
except Exception as e:
    raise RuntimeError("操作失败") from e
```

### 8.2 日志配置
```python
import logging

# 配置
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

# 使用
logger = logging.getLogger(__name__)
logger.debug("调试信息")
logger.info("一般信息")
logger.warning("警告")
logger.error("错误")
logger.critical("严重错误")
```

---

## 9. 元类和反射

### 9.1 元类
```python
# 自定义元类
class SingletonMeta(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Logger(metaclass=SingletonMeta):
    pass

a = Logger()
b = Logger()
print(a is b)  # True
```

### 9.2 反射
```python
class Person:
    def __init__(self, name):
        self.name = name
    
    def greet(self):
        return f"Hello, I'm {self.name}"

p = Person("Alice")

# 获取属性
getattr(p, 'name')          # 'Alice'
hasattr(p, 'name')          # True
setattr(p, 'age', 25)       # 设置属性

# 获取方法
method = getattr(p, 'greet')
method()  # 调用

# 检查类型
isinstance(p, Person)       # True
type(p)                     # <class '__main__.Person'>
p.__class__                 # <class '__main__.Person'>
```

---

## 10. 性能优化

### 10.1 性能分析
```python
import cProfile
import pstats

# 分析代码
profiler = cProfile.Profile()
profiler.enable()

# 你的代码
result = slow_function()

profiler.disable()
stats = pstats.Stats(profiler)
stats.sort_stats('cumulative')
stats.print_stats(10)
```

### 10.2 优化技巧
```python
# 1. 使用生成器替代列表
# 差
sum([x**2 for x in range(1000000)])
# 好
sum(x**2 for x in range(1000000))

# 2. 使用局部变量
# 差
def slow():
    for i in range(1000):
        len(some_list)
# 好
def fast():
    length = len
    for i in range(1000):
        length(some_list)

# 3. 使用合适的数据结构
from collections import defaultdict, Counter

# 4. 缓存结果
from functools import lru_cache

@lru_cache(maxsize=128)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)
```

---

## 学习建议

1. **理解原理**：不要只记语法，理解背后的设计思想
2. **阅读源码**：学习Python标准库的实现
3. **实践项目**：将高级特性应用到实际项目中
4. **性能意识**：关注代码的效率和内存使用
5. **保持简洁**：高级特性是为了让代码更清晰，不是更复杂

---

*参考：[Python Cookbook](https://diveintopython3.problemsolving.io/)*
