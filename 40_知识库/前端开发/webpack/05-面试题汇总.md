# Webpack 面试题汇总

## 一、基础概念

### 1. 什么是 Webpack？

**答案**：
Webpack 是一种用于构建 JavaScript 应用程序的**静态模块打包器**。它能够以一种相对一致且开放的处理方式，加载应用中的所有资源文件（图片、CSS、视频、字体文件等），并将其合并打包成浏览器兼容的 Web 资源文件。

**核心功能**：
- 模块打包：整合不同模块文件，保证模块间引用和执行
- 代码编译：通过 Loader 将不同格式文件转译为浏览器可执行文件
- 扩展功能：通过 Plugin 实现代码分割、混淆、压缩、按需加载等

---

### 2. Webpack 与 Grunt/Gulp 的区别？

**答案**：
| 工具 | 定位 | 特点 |
|------|------|------|
| **Grunt/Gulp** | 任务执行器 | 通过配置任务流程，执行文件转换、压缩等操作 |
| **Webpack** | 模块打包器 | 从入口文件开始，递归构建依赖图，统一打包输出 |

- Grunt/Gulp 关注**过程**：定义任务流，按步骤执行
- Webpack 关注**模块**：自动处理模块依赖，统一打包

---

## 二、Loader 相关

### 3. 常见的 Loader 有哪些？

**答案**：
| Loader | 作用 |
|--------|------|
| `babel-loader` | 将 ES6+ 转译为 ES5 |
| `ts-loader` | TypeScript 转 JavaScript |
| `css-loader` | 解析 CSS 文件，支持模块化、导入 |
| `style-loader` | 将 CSS 注入到 DOM |
| `sass-loader/less-loader` | 预处理器编译 |
| `file-loader/url-loader` | 处理资源文件（Webpack 5 已内置） |
| `html-loader` | 处理 HTML 中的资源 |
| `eslint-loader` | 代码规范检查 |
| `thread-loader` | 多线程打包 |
| `cache-loader` | 缓存 loader 结果 |

---

### 4. Loader 的执行顺序是怎样的？

**答案**：
1. **从右到左**，**从下到上**（数组中）执行
2. 可以使用 `enforce` 控制优先级：
   - `pre`：优先执行
   - `normal`：默认执行
   - `post`：延后执行

```javascript
{
  test: /\.scss$/,
  use: ['style-loader', 'css-loader', 'sass-loader']
  // 执行顺序：sass-loader → css-loader → style-loader
}
```

---

### 5. 如何保证多个 Loader 按想要的顺序执行？

**答案**：
通过 `enforce` 属性控制：
```javascript
{
  test: /\.js$/,
  enforce: 'pre',  // 优先执行
  loader: 'eslint-loader'
}
```

执行顺序：
```
Pitching 阶段（从左到右）：
post → inline → normal → pre

Normal 阶段（从右到左）：
pre → normal → inline → post
```

---

### 6. 如何编写一个 Loader？

**答案**：
```javascript
// 基础结构
module.exports = function(source) {
  // source: 源文件内容
  // 处理逻辑
  const result = source.toUpperCase();
  return result;
};

// 使用 this.callback
module.exports = function(source, sourceMap, meta) {
  this.callback(null, result, sourceMap, meta);
};
```

**关键点**：
- Loader 本质是一个函数
- 接收源内容，返回转换后的内容
- 支持链式调用
- 使用 `this.callback` 返回多个值

---

## 三、Plugin 相关

### 7. 常见的 Plugin 有哪些？

**答案**：
| Plugin | 作用 |
|--------|------|
| `html-webpack-plugin` | 自动生成 HTML 并引入资源 |
| `mini-css-extract-plugin` | 提取 CSS 为独立文件 |
| `clean-webpack-plugin` | 清理输出目录 |
| `copy-webpack-plugin` | 复制静态资源 |
| `terser-webpack-plugin` | 压缩 JS 代码 |
| `webpack-bundle-analyzer` | 可视化分析打包体积 |
| `compression-webpack-plugin` | Gzip 压缩 |
| `hot-module-replacement-plugin` | 热模块替换 |
| `define-plugin` | 定义全局环境变量 |
| `dll-plugin` | 动态链接库预编译 |

---

### 8. Loader 和 Plugin 的区别？

**答案**：
| 特性 | Loader | Plugin |
|------|--------|--------|
| **本质** | 函数，负责文件转换 | 类，监听 webpack 钩子 |
| **作用** | 转换非 JS 文件为 JS 模块 | 扩展 webpack 功能 |
| **配置** | `module.rules` | `plugins` 数组 |
| **执行时机** | 模块加载时 | 构建生命周期各阶段 |
| **职责** | 单一（文件转换） | 丰富多样（优化、压缩等） |

---

### 9. 如何编写一个 Plugin？

**答案**：
```javascript
class MyPlugin {
  constructor(options) {
    this.options = options;
  }

  apply(compiler) {
    // 注册钩子
    compiler.hooks.done.tap('MyPlugin', (stats) => {
      console.log('构建完成！');
    });
    
    compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
      // 异步操作
      callback();
    });
  }
}

module.exports = MyPlugin;
```

**关键点**：
- 必须包含 `apply(compiler)` 方法
- 通过 `compiler.hooks` 监听构建阶段
- 使用 `tap/tapAsync/tapPromise` 注册回调

---

## 四、原理相关

### 10. Webpack 的构建流程是什么？

**答案**：
构建流程分为三个阶段：

**1. 初始化阶段**：
- 合并配置（配置文件 + CLI 参数）
- 创建 Compiler 实例
- 加载所有 Plugin
- 解析 entry 确定入口文件

**2. 构建阶段**：
- 从入口开始，调用 Loader 转译模块
- 使用 Acorn 解析为 AST，分析依赖
- 递归处理依赖模块
- 构建 ModuleGraph（模块依赖图）

**3. 生成阶段**：
- 根据 ModuleGraph 构建 ChunkGraph
- 执行代码优化（Tree Shaking、Scope Hoisting）
- 生成 Assets 资源
- 写入文件系统

---

### 11. HMR（热更新）原理是什么？

**答案**：
```
1. Webpack Dev Server（WDS）托管静态资源
2. WDS 向 bundle 注入 HMR 客户端代码
3. 浏览器与 WDS 建立 WebSocket 连接
4. 文件变化 → Webpack 增量构建 → 生成新 hash
5. WDS 推送 hash 到浏览器
6. 浏览器请求 manifest 获取变更范围
7. 浏览器加载变更模块
8. 执行 module.hot.accept 回调，更新页面
```

---

### 12. Tree Shaking 原理是什么？

**答案**：
Tree Shaking 是基于 **ES Module** 规范的**死代码消除**技术。

**工作流程**：
1. **标记阶段**：分析模块导出，标记哪些被使用
2. **清除阶段**：Terser 删除未使用的导出代码

**开启条件**：
- 使用 ES Module（import/export）
- 启用代码优化：`mode: 'production'` 或 `optimization.usedExports: true`
- 配置 `sideEffects` 处理有副作用的文件

---

### 13. 文件指纹（Hash）是什么？有哪几种？

**答案**：
文件指纹用于版本管理和缓存控制。

| 类型 | 说明 | 使用场景 |
|------|------|----------|
| `[hash]` | 每次构建生成的唯一 hash | 不推荐 |
| `[chunkhash]` | 根据 chunk 生成 | JS 文件（推荐） |
| `[contenthash]` | 根据文件内容生成 | CSS 文件（推荐） |

```javascript
output: {
  filename: 'js/[name].[chunkhash:8].js'
}

new MiniCssExtractPlugin({
  filename: 'css/[name].[contenthash:8].css'
})
```

---

### 14. Babel 原理是什么？

**答案**：
Babel 工作流程：`解析(parse) → 转换(transform) → 生成(generate)`

1. **解析**：代码 → Token 流 → AST
2. **转换**：遍历 AST，应用插件转换节点
3. **生成**：新 AST → 目标代码

```
源代码 → @babel/parser → AST → @babel/traverse → 
AST 转换 → @babel/generator → 目标代码
```

---

### 15. Source Map 是什么？如何选择？

**答案**：
Source Map 用于将压缩后的代码映射回源码，方便调试。

**推荐配置**：
- **开发环境**：`devtool: 'eval-cheap-module-source-map'`
  - 构建速度快
  - 可调试
  
- **生产环境**：`devtool: 'hidden-source-map'`
  - 不暴露源码
  - 用于错误监控

**模式对比**：
| 模式 | 构建速度 | 调试精度 | 生产环境 |
|------|---------|---------|---------|
| `eval` | 最快 | 低 | ❌ |
| `cheap-source-map` | 快 | 行级 | ❌ |
| `source-map` | 慢 | 最高 | ✅ |
| `hidden-source-map` | 慢 | 最高 | ✅ |

---

## 五、优化相关

### 16. 如何优化 Webpack 构建速度？

**答案**：

**开发环境**：
1. 使用 `cache: { type: 'filesystem' }` 开启持久化缓存
2. 启用 HMR 热更新
3. 使用 `thread-loader` 多线程打包
4. 配置合理的 `devtool`（如 `eval-cheap-module-source-map`）

**生产环境**：
1. 升级 Node 和 Webpack 到最新版本
2. 缩小 Loader 搜索范围（`include/exclude`）
3. 使用 `DllPlugin` 预编译第三方库
4. 使用 `externals` 排除 CDN 引入的库
5. 开启 Babel 缓存 `cacheDirectory: true`

---

### 17. 如何优化 Webpack 打包体积？

**答案**：

1. **Tree Shaking**：移除未使用代码
2. **Scope Hoisting**：合并模块作用域
3. **代码分割**：
   - `splitChunks` 提取公共代码
   - 动态导入 `import()` 实现懒加载
4. **压缩代码**：
   - `TerserPlugin` 压缩 JS
   - `CssMinimizerPlugin` 压缩 CSS
5. **CDN 引入**：`externals` 排除第三方库
6. **Gzip 压缩**：`compression-webpack-plugin`

---

### 18. 什么是代码分割？如何实现？

**答案**：
代码分割将代码拆分为多个 chunk，实现按需加载。

**实现方式**：
1. **多入口**：`entry: {a, b}` - 多页面应用
2. **动态导入**：`import()` - 路由懒加载
3. **SplitChunks**：提取公共代码

```javascript
// 动态导入
const Home = () => import('./Home.vue');

// SplitChunks
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors'
      }
    }
  }
}
```

---

### 19. 懒加载和预加载的区别？

**答案**：
| 特性 | 懒加载 | 预加载 |
|------|--------|--------|
| **触发时机** | 需要时（如点击事件） | 浏览器空闲时 |
| **配置方式** | `import()` | `webpackPrefetch: true` |
| **使用场景** | 非首屏必要代码 | 高概率会使用到的代码 |

```javascript
// 懒加载
button.onclick = () => {
  import('./modal.js').then(module => {
    module.show();
  });
};

// 预加载
import(/* webpackPrefetch: true */ './modal.js');
```

---

### 20. Webpack 5 有哪些新特性？

**答案**：

1. **持久化缓存**：`cache: { type: 'filesystem' }`
2. **Asset Modules**：内置资源处理，替代 file-loader/url-loader
3. **Module Federation**：模块联邦，支持微前端
4. **Tree Shaking 增强**：支持嵌套模块
5. **Top Level Await**：支持顶层 await
6. **更好的 Long Term Caching**：优化 chunk id 生成

---

## 六、高级问题

### 21. Compiler 和 Compilation 的区别？

**答案**：
| 特性 | Compiler | Compilation |
|------|----------|-------------|
| **数量** | 全局单例 | 每次构建新建 |
| **生命周期** | webpack 启动到关闭 | 单次构建过程 |
| **作用** | 完整配置信息 | 当前构建上下文 |
| **钩子数量** | 200+ 个 | 细粒度构建钩子 |

**关系**：
- Compiler 包含 Compilation
- Compilation 通过 `compiler.hooks.compilation` 创建

---

### 22. Webpack 如何监听文件变化？

**答案**：
通过 `watch` 模式监听文件：
```javascript
module.exports = {
  watch: true,
  watchOptions: {
    ignored: /node_modules/,      // 忽略目录
    aggregateTimeout: 300,        // 防抖延迟
    poll: 1000                    // 轮询间隔
  }
};
```

**原理**：
- 轮询检测文件最后修改时间
- 变化后缓存，等待 `aggregateTimeout` 后统一执行

---

### 23. 什么是 Scope Hoisting？

**答案**：
将符合条件的多个模块合并到同一个函数作用域中，减少函数声明和闭包，优化代码体积。

```javascript
// 开启前
(function(module, exports) { module.exports = 'a'; })();
(function(module, exports) { var a = require('./a'); })();

// 开启后
(function() { var a = 'a'; })();
```

**开启方式**：`mode: 'production'` 或 `optimization.concatenateModules: true`

---

### 24. Webpack 中的 Tapable 是什么？

**答案**：
Tapable 是 webpack 内部使用的**发布订阅**库，用于实现 Plugin 系统。

**钩子类型**：
| 类型 | 执行方式 |
|------|---------|
| `SyncHook` | 同步串行 |
| `SyncBailHook` | 同步串行，返回非 undefined 则停止 |
| `SyncWaterfallHook` | 同步串行，返回值传递给下一个 |
| `AsyncParallelHook` | 异步并行 |
| `AsyncSeriesHook` | 异步串行 |

---

### 25. Webpack 如何处理循环依赖？

**答案**：
Webpack 通过**模块缓存**机制处理循环依赖：

```javascript
// a.js
import { b } from './b';
export const a = 'a';
console.log(b);  // 可以访问 b，值为 undefined

// b.js
import { a } from './a';
export const b = 'b';
console.log(a);  // 可以访问 a，值为 undefined
```

**原理**：
1. 模块加载前创建空对象作为缓存
2. 其他模块引入时从缓存获取
3. 模块执行完成后填充缓存

**注意**：循环依赖可能导致部分导出为 `undefined`，应避免循环依赖设计。
