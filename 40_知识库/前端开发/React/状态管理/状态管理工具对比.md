---
title: "状态管理工具对比"
date: 2026-02-11
tags: [前端框架, 状态管理, React, 对比]
category: 前端开发
status: active
---

# 状态管理工具对比

## 综合对比表

| 特性 | Zustand | Redux Toolkit | MobX | Jotai | Recoil | Valtio |
|-----|---------|---------------|------|-------|--------|--------|
| **编程范式** | 极简 Store | 集中式 Flux | 响应式 OOP | 原子化 FP | 原子化 FP | 可变状态 |
| **学习曲线** | ⭐⭐ 极低 | ⭐⭐⭐ 中等 | ⭐⭐⭐ 中等 | ⭐⭐ 低 | ⭐⭐⭐ 中等 | ⭐ 极低 |
| **样板代码** | 极少 | 中等 | 较少 | 极少 | 较少 | 极少 |
| **包体积** | ~1KB | ~10KB | ~16KB | ~1KB | ~18KB | ~1KB |
| **TypeScript** | 优秀 | 优秀 | 良好 | 优秀 | 良好 | 良好 |
| **DevTools** | 基础 | 强大 | 基础 | 基础 | 基础 | 基础 |
| **中间件** | 丰富 | 非常丰富 | 少量 | 少量 | 少量 | 少量 |
| **更新粒度** | Store 级 | Store 分支级 | 属性级 | 原子级 | 原子级 | 属性级 |
| **Provider** | 不需要 | 需要 | 不需要 | 可选 | 需要 | 不需要 |
| **稳定性** | 稳定 | 稳定 | 稳定 | 稳定 | 实验性 | 稳定 |
| **社区活跃度** | 高 | 极高 | 中 | 高 | 中 | 中 |

## 按场景推荐

### 1. 项目规模

#### 小型应用（< 10 个共享状态）
**推荐**: `useState + Context` 或 **Valtio**

理由：
- 避免引入不必要的依赖
- Valtio 可以直接修改状态，学习成本最低
- 快速原型开发

```typescript
// Valtio 示例
const state = proxy({ count: 0 })
// 直接使用: state.count++
```

#### 中型应用（10-50 个共享状态）
**推荐**: **Zustand** ⭐

理由：
- 极简 API，无需 Provider
- 丰富的中间件生态
- 优秀的 TypeScript 支持
- 性能良好

```typescript
// Zustand 示例
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 }))
}))
```

#### 大型应用（> 50 个共享状态，多人协作）
**推荐**: **Redux Toolkit** + **TanStack Query**

理由：
- 严格的数据流规范
- 强大的 Redux DevTools（时间旅行、状态快照）
- 成熟的中间件生态
- 更好的可维护性和可预测性

```typescript
// Redux Toolkit 示例
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1 }
  }
})
```

### 2. 编程风格偏好

#### 喜欢函数式编程
**推荐**: **Jotai** 或 **Redux Toolkit**

- Jotai: 原子组合，函数式风格
- Redux: 纯函数 reducer，不可变更新

#### 喜欢面向对象编程
**推荐**: **MobX**

- 类定义 Store
- 装饰器语法
- 自动依赖追踪

```typescript
// MobX 示例
class Store {
  @observable count = 0
  @action increment() { this.count++ }
}
```

#### 喜欢直接修改状态（Vue 风格）
**推荐**: **Valtio**

- Proxy 自动追踪
- 直接赋值即可
- 无需不可变性

```typescript
// Valtio 示例
state.count++  // 直接修改
```

### 3. 性能需求

#### 需要细粒度更新（高频更新场景）
**推荐**: **Jotai** 或 **MobX**

- Jotai: 原子级订阅，组件只订阅需要的原子
- MobX: 自动追踪依赖，精确到属性级别

#### 一般性能需求
**推荐**: **Zustand** 或 **Redux Toolkit**

- Zustand: 选择器模式优化
- Redux: connect / useSelector 优化

## 现代 React 技术栈推荐

### 2024 年推荐组合

```
┌─────────────────────────────────────────────────┐
│               现代 React 应用架构                 │
├─────────────────────────────────────────────────┤
│                                                 │
│   服务器状态 ────────→ TanStack Query ⭐         │
│      (API 数据、缓存、同步)                        │
│                                                 │
│   客户端状态 ────────→ Zustand ⭐                │
│      (UI 状态、主题、用户信息)                     │
│                                                 │
│   表单状态 ─────────→ React Hook Form           │
│      (表单字段、验证)                             │
│                                                 │
│   URL 状态 ─────────→ React Router              │
│      (路由参数、查询字符串)                        │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 为什么这样组合？

1. **TanStack Query** 处理服务器状态
   - 自动缓存、重取、去重
   - 无需手动管理 loading/error 状态
   - 比 Redux + Thunk 简洁得多

2. **Zustand** 处理客户端状态
   - 比 Redux 简单 10 倍
   - 比 Context 性能更好
   - 足够应对大多数场景

3. **避免的错误组合**
   - ❌ Redux + Redux-Saga（过于复杂）
   - ❌ 把所有状态都放到 Redux 中（包括服务器状态）
   - ❌ 在 Redux 中缓存 API 数据（用 TanStack Query 替代）

## 迁移路径

### 从 Redux 迁移到 Zustand
适合场景：
- 项目规模变小，Redux 显得笨重
- 想要减少样板代码

步骤：
1. 逐个 slice 迁移
2. 先迁移简单的 UI 状态
3. 保留复杂的服务器状态管理

### 从 useState + Props Drilling 迁移
适合场景：
- Prop drilling 超过 3 层
- 状态需要在多个不相关组件间共享

推荐路径：
- 简单场景 → Context
- 中等复杂度 → Zustand
- 复杂场景 → Redux Toolkit

## 特殊场景

### 需要状态持久化
所有工具都支持：
- Zustand: `persist` 中间件
- Redux: `redux-persist`
- MobX: `mobx-persist-store`
- Jotai: `atomWithStorage`
- Valtio: `proxyWithStorage`

### 需要服务端渲染 (SSR)
支持度排名：
1. Redux（最成熟）
2. Zustand（良好）
3. Jotai（良好）
4. MobX（需要配置）
5. Valtio（有限支持）

### 需要时间旅行调试
**唯一选择**: **Redux**

Redux DevTools 是状态管理调试的黄金标准，支持：
- 时间旅行（撤销/重做）
- 状态快照
- Action 回放

## 总结

| 你的情况 | 推荐方案 |
|---------|---------|
| 快速原型/简单应用 | Valtio |
| 大多数 React 应用 | Zustand + TanStack Query ⭐ |
| 大型/企业级应用 | Redux Toolkit + TanStack Query |
| 需要细粒度更新 | Jotai |
| 喜欢 OOP 风格 | MobX |
| 需要最强调试 | Redux |
| 实验性/学习 | Recoil (谨慎用于生产) |

## 相关笔记

- [[Zustand]] - 极简状态管理
- [[Redux]] - 集中式状态管理
- [[MobX]] - 响应式状态管理
- [[Jotai]] - 原子化状态管理
- [[Recoil]] - Facebook 原子化方案
- [[Valtio]] - 可变状态管理
- [[TanStack-Query]] - 服务器状态管理
- [[原子化状态管理]] - 原子化范式详解
